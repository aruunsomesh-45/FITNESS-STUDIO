[
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "81bc800c-70c4-4899-85e4-e229072e34e3",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC001-Contact Form: Successful Submission with Valid Data",
    "description": "Verify that the contact form submits successfully when all fields are valid, and the backend returns success with the message ID.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Contact link to navigate to the contact form page\n        frame = context.pages[-1]\n        # Click on the Contact link in the top navigation to go to the contact form page\n        elem = frame.locator('xpath=html/body/main/nav/div/div/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Form submission failed: Invalid response from server')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The contact form submission did not succeed as expected. The backend did not return a success response with a valid message ID, or the frontend did not display the success notification.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The contact form page could not be accessed due to a navigation failure leading to a chrome error page. The website issue has been reported. Therefore, the task to verify the contact form submission cannot be completed.\nBrowser Console Logs:\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0AC3A0074010000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x17401bea900]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x17401bea900]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x17401bea900]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x17401bea900]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat) (at http://localhost:3000/:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/contact?_rsc=vusbg:0:0)\n[ERROR] Failed to fetch RSC payload for http://localhost:3000/contact. Falling back to browser navigation. TypeError: Failed to fetch\n    at createFetch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:2552:24)\n    at fetchServerResponse (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:2456:27)\n    at navigateDynamicallyWithNoPrefetch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7605:90)\n    at navigate (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7424:15)\n    at navigateReducer (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7900:45)\n    at clientReducer (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12246:61)\n    at Object.action (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12492:55)\n    at runAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12397:38)\n    at dispatchAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12460:9)\n    at Object.dispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12490:40)\n    at http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1442:29\n    at startTransition (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:5494:31)\n    at dispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1441:13)\n    at dispatchAppRouterAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1423:5)\n    at dispatchNavigateAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12544:49)\n    at http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:617:13\n    at Object.startTransition (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_9f1f6bb2._.js:1279:31)\n    at linkClicked (http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:616:24)\n    at onClick (http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:857:13)\n    at executeDispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10308:13)\n    at runWithFiberInDEV (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:959:74)\n    at processDispatchQueue (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10334:41)\n    at http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10609:13\n    at batchedUpdates$1 (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:2247:44)\n    at dispatchEventForPluginEventSystem (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10410:9)\n    at dispatchEvent (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:12925:37)\n    at dispatchDiscreteEvent (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:12907:64)\n    at eval (eval at evaluate (:234:30), <anonymous>:1:12)\n    at UtilityScript.evaluate (<anonymous>:241:19)\n    at UtilityScript.<anonymous> (<anonymous>:1:44) (at http://localhost:3000/_next/static/chunks/a5c45_next_dist_0e5277d7._.js:3117:31)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/__nextjs_font/geist-latin.woff2:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/__nextjs_original-stack-frames:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767721501509//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.113Z",
    "modified": "2025-12-03T13:15:21.662Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "89676c2b-9fe0-467b-8aa0-3836390112d5",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC002-Contact Form: Client-Side Validation for Mandatory Fields",
    "description": "Verify that the form enforces field requirements with appropriate client-side validation errors when fields are missing or invalid.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Contact' link to navigate to the contact form page.\n        frame = context.pages[-1]\n        # Click on the 'Contact' link in the navigation to go to the contact form page.\n        elem = frame.locator('xpath=html/body/main/nav/div/div/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Form submission successful!')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The form did not enforce field requirements with appropriate client-side validation errors when fields are missing or invalid as specified in the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped because the contact form page is inaccessible due to a broken link or loading error. The 'Contact' button leads to a chrome error page, preventing further validation tests.\nBrowser Console Logs:\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0D83B0074230000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x23740276ef80]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x23740276ef80]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x23740276ef80]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x23740276ef80]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat) (at http://localhost:3000/:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/contact?_rsc=vusbg:0:0)\n[ERROR] Failed to fetch RSC payload for http://localhost:3000/contact. Falling back to browser navigation. TypeError: Failed to fetch\n    at createFetch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:2552:24)\n    at fetchServerResponse (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:2456:27)\n    at navigateDynamicallyWithNoPrefetch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7605:90)\n    at navigate (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7424:15)\n    at navigateReducer (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:7900:45)\n    at clientReducer (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12246:61)\n    at Object.action (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12492:55)\n    at runAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12397:38)\n    at dispatchAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12460:9)\n    at Object.dispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12490:40)\n    at http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1442:29\n    at startTransition (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:5494:31)\n    at dispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1441:13)\n    at dispatchAppRouterAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:1423:5)\n    at dispatchNavigateAction (http://localhost:3000/_next/static/chunks/a5c45_next_dist_client_db5b1acd._.js:12544:49)\n    at http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:617:13\n    at Object.startTransition (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_9f1f6bb2._.js:1279:31)\n    at linkClicked (http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:616:24)\n    at onClick (http://localhost:3000/_next/static/chunks/a5c45_cfa3ec23._.js:857:13)\n    at executeDispatch (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10308:13)\n    at runWithFiberInDEV (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:959:74)\n    at processDispatchQueue (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10334:41)\n    at http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10609:13\n    at batchedUpdates$1 (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:2247:44)\n    at dispatchEventForPluginEventSystem (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:10410:9)\n    at dispatchEvent (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:12925:37)\n    at dispatchDiscreteEvent (http://localhost:3000/_next/static/chunks/a5c45_next_dist_compiled_react-dom_46d3d50e._.js:12907:64)\n    at eval (eval at evaluate (:234:30), <anonymous>:1:12)\n    at UtilityScript.evaluate (<anonymous>:241:19)\n    at UtilityScript.<anonymous> (<anonymous>:1:44) (at http://localhost:3000/_next/static/chunks/a5c45_next_dist_0e5277d7._.js:3117:31)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/__nextjs_font/geist-latin.woff2:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/__nextjs_original-stack-frames:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767733137717//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.118Z",
    "modified": "2025-12-03T13:15:33.291Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "957be28b-b5b5-4b45-9c4f-7db3406c3dad",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC003-Contact Form: Server-Side Validation Error Handling",
    "description": "Verify that the POST API rejects invalid data with HTTP 400 responses containing descriptive error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Successful submission of contact form').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The POST API did not reject invalid data as expected with HTTP 400 responses containing descriptive error messages.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Navigation to the API endpoint page failed, so browser-based testing is not possible. To verify that the POST API rejects invalid data with HTTP 400 responses and descriptive error messages, we need to perform direct POST requests programmatically or with an API testing tool. Task stopped as browser interaction is not feasible.\nBrowser Console Logs:\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0AC3A0034010000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x13400d07600]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x13400d07600]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x13400d07600]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (at http://localhost:3000/:0:0)\n[WARNING] [.WebGL-0x13400d07600]GL Driver Message (OpenGL, Performance, GL_CLOSE_PATH_NV, High): GPU stall due to ReadPixels (this message will no longer repeat) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767593058613//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.124Z",
    "modified": "2025-12-03T13:13:13.199Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "68d62df7-e26c-4a53-a848-724ac59c8fbc",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC004-Contact Form: Persistence Verification in Supabase Database",
    "description": "Verify that successfully submitted contact form data is correctly saved in the 'contact_messages' Supabase table with expected schema alignment.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-12-03T13:10:27.131Z",
    "modified": "2025-12-03T13:10:27.131Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "c4bc2a4d-d444-4acd-9ed1-29eaf5a36ffe",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC005-API Endpoint: Fetch Recent Contact Messages with Valid Admin API Key",
    "description": "Verify GET /api/contact returns the 20 most recent contact messages when requested with valid API key authentication.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No contact messages found').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The GET /api/contact API did not return the expected 20 most recent contact messages with valid API key authentication as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767531935889//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.137Z",
    "modified": "2025-12-03T13:12:12.057Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "725786fb-81bc-401f-8c61-ef3307a7d9f4",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC006-API Endpoint: Refuse Fetching Contact Messages Without or With Invalid API Key",
    "description": "Verify that GET /api/contact returns HTTP 401 Unauthorized when called without an API key or with an invalid API key",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authorized Access Granted').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: GET /api/contact did not return HTTP 401 Unauthorized as expected when called without or with an invalid API key.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767582556826//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.143Z",
    "modified": "2025-12-03T13:13:02.682Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "72188feb-3404-47b1-bf6c-74f0fdac9a68",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC007-Supabase Client Initialization Failure Handling",
    "description": "Verify the system handles misconfigured or missing environment variables for Supabase client setup gracefully without crashing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Supabase client initialized successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Supabase client initialization did not succeed as expected due to missing or misconfigured environment variables. The system should handle this gracefully without crashing, but the success message was not found.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767587179862//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.149Z",
    "modified": "2025-12-03T13:13:07.439Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "fbf19185-46a5-4694-a9fb-eace508d7dc1",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC008-Contact Form: Edge Case Input Length Boundaries",
    "description": "Verify form validation and API accept inputs at exact minimum and maximum length boundaries for each field.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Form submission successful with message ID').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The API did not accept the inputs at exact minimum and maximum length boundaries as expected, or did not respond with HTTP 201 and message ID.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767597375704//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.155Z",
    "modified": "2025-12-03T13:13:17.501Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "622a7557-14e7-48ec-a8c2-5c4e498375ec",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC009-Contact Form: Cross-Site Scripting (XSS) Prevention and Sanitization",
    "description": "Verify user inputs containing script tags or code are sanitized and do not cause XSS vulnerabilities after submission and database storage.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Alert: XSS vulnerability detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User inputs containing script tags or code are not properly sanitized, leading to potential XSS vulnerabilities after submission and database storage.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767604935749//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.160Z",
    "modified": "2025-12-03T13:13:25.059Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "6c20f165-5edb-46d1-a240-7ca53bd89fd8",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC010-Contact Form: Server Error Handling on Database Failures",
    "description": "Simulate server or database failure during POST submission and verify API returns HTTP 500 error with appropriate message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Submission Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The POST /api/contact submission did not return HTTP 500 error as expected due to simulated database failure, and the frontend did not display the appropriate error notification to the user.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767621016919//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.166Z",
    "modified": "2025-12-03T13:13:41.140Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "cc7d521b-72bd-492c-aa79-ff5d1a308f28",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC011-Contact Form: Verify Real-Time Client-Side Validation Feedback",
    "description": "Verify that as the user types into each field, real-time validation messages appear and disappear appropriately according to field input validity.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Validation Successful! All inputs are correct.').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Real-time validation messages did not appear and disappear as expected when typing into each field.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/176476762203665//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.171Z",
    "modified": "2025-12-03T13:13:42.158Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "bc079ead-8098-4fb9-b57b-d67ee1a0941e",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC012-Contact Form: Form Reset Behavior After Successful Submission",
    "description": "Verify that the contact form resets all fields and validation states after a successful submission.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Form submission failed due to validation errors').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The contact form did not reset all fields and validation states after a successful submission as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/1764767642934621//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.178Z",
    "modified": "2025-12-03T13:14:03.082Z"
  },
  {
    "projectId": "2f31fed5-9782-482c-8574-7e920171962f",
    "testId": "80258a94-8fa4-4f9e-b34e-e86acc4932e5",
    "userId": "c478e428-3051-70f4-f122-6f4e22b5117a",
    "title": "TC013-Admin API Key Security: Verify Different Roles Cannot Fetch Messages Without Key",
    "description": "Verify that users without a valid API key (including anonymous or logged-in site users) cannot access GET /api/contact messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Access Granted: API Key Validated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users without a valid API key should not access GET /api/contact messages, but the expected unauthorized access was not enforced.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c478e428-3051-70f4-f122-6f4e22b5117a/176476765708352//tmp/test_task/result.webm",
    "created": "2025-12-03T13:10:27.183Z",
    "modified": "2025-12-03T13:14:17.219Z"
  }
]
